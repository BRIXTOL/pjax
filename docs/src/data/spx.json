[
  {
    "href": "index.html",
    "url": "/index.html",
    "anchor": "",
    "title": "SPX | Single Page XHR",
    "text": "Documentation OR Examples 0.1.2-beta.1"
  },
  {
    "href": "api/index.html",
    "url": "/api",
    "anchor": "",
    "title": "Methods",
    "text": "Api In addition to Lifecycle events, you also have a list of methods available. Methods will allow you some basic programmatic control of the SPX session occurring and provides access to the cache store, snapshot store and various other operational utilities. The session Returns Promise<Page> Asynchronous false The hydrate url Promise<Page> cache > hydrate > load Returns Promise<Page> Triggers a programmatic fetch. The XHR request response is not cached and no state reference are touched. Returns Document The prefetch url <a href=\"*\"></a> Promise<Page> request > cache Document The visit url Promise<Page> replace > request > cache > render > load The store url state Promise<Page> The capture Promise<Page>"
  },
  {
    "href": "lifecyclecache/index.html",
    "url": "/lifecyclecache",
    "anchor": "",
    "title": "Cache Event",
    "text": "Lifecyclecache The cache event is fired after the record was saved to memory. This event will fire for prefetch fetch Cancellable false Asynchronous false"
  },
  {
    "href": "lifecyclefetch/index.html",
    "url": "/lifecyclefetch",
    "anchor": "",
    "title": "Fetch Event",
    "text": "Lifecyclefetch The fetch event will be triggered before an XHR request begins and a page is fetched over the wire. This event will be fired for prefetch hydrate trigger type state Cancellable false Asynchronous true"
  },
  {
    "href": "lifecycleload/index.html",
    "url": "/lifecycleload",
    "anchor": "",
    "title": "Load Event",
    "text": "Lifecycleload The load event is the final lifecycle event to be triggered. Use this event to re-initialize any third party scripts. The load event will only execute after navigation has concluded, targets have been replaced and the document is ready. Cancellable false Asynchronous false"
  },
  {
    "href": "lifecycleprefetch/index.html",
    "url": "/lifecycleprefetch",
    "anchor": "",
    "title": "Prefetch Event",
    "text": "Lifecycleprefetch The prefetch event will be triggered for every prefetch request. Prefetch events are fired when hover intersect proximity type Cancellable false Asynchronous false"
  },
  {
    "href": "lifecyclestore/index.html",
    "url": "/lifecyclestore",
    "anchor": "",
    "title": "SPX Events - Store",
    "text": "Lifecyclestore The store event will be triggered immediately after a request has finished but before a snapshot and page record is saved to memory. This Lifecycle also allows you to augment the snapshot Document Cancellable false Asynchronous false"
  },
  {
    "href": "lifecyclevisit/index.html",
    "url": "/lifecyclevisit",
    "anchor": "",
    "title": "Visit Event",
    "text": "Lifecyclevisit The visit event will be triggered when a mousedown <a href=\"*\"></a> click Cancellable false Asynchronous false"
  },
  {
    "href": "lifecyclerender/index.html",
    "url": "/lifecyclerender",
    "anchor": "",
    "title": "Render Event",
    "text": "Lifecyclerender The render event will be triggered before a page or fragment is rendered (replaced) in the dom. For every target target newTarget target newTarget The Hydrate Render Cancellable false Asynchronous false"
  },
  {
    "href": "reference/index.html",
    "url": "/reference",
    "anchor": "",
    "title": "Reference",
    "text": "Reference A SPX navigation sessions will begin immediately after a connection was initialized via spx.connect() spx.session() The spx.session() The merged default and custom configuration spx.connect() The connected observers being used in the session. A A A UUID A Set State represents per-page configuration. This store is immutable and created for every unique url /path /pathname?query=param State modifications can be carried out using attributes, methods or from within lifecycle events that support it. When using the spx.visit() options State saved to history stack is stored with the config A UUID reference to the page snapshot HTML Document element. A URL pathname + parameter combination key reference (this value excludes #hashes A previous pathname + parameter combination key reference, ie: the previous page The document title, ie: the text content contained in <title></title> An enumerable number reference that informs upon how this store was created. Scroll position of the next navigation. The y scrollTop x scrollLeft Parsed location reference of the page. The origin window.location.origin hostname www https://www.brixtol.com brixtol.com Configuration model. This values defined here are applied on a per-page basis and will reflect the visits render options. These settings merge the connection defaults and attribute annotations (if defined) to instruct SPX on how to perform its rendering and cache operation."
  },
  {
    "href": "routing/index.html",
    "url": "/routing",
    "anchor": "",
    "title": "Routing",
    "text": "Routing SPX exposes a routing approach for cases where per-page lifecycle control is desired. Because we are dealing with SSR markup and intercepting navigations we are able to intercept and execute operations at different points in the render cycles. SPX routes accept components which can be leveraged in your application. An SPX component is just an object literal that contains lifecycle methods, otherwise known as hooks. Components are a mechanism that encapsulates logic for specific routes. Here’s an SPX component: The module exposes a low-level routing approach using simple wildcard path matching. Routes execute right before fragments are replaced in the rendering lifecycle. Routes allow you to augment the target documents and state before replacement occur."
  },
  {
    "href": "api/clear/index.html",
    "url": "/api/clear",
    "anchor": "",
    "title": "Clear",
    "text": "Api Clear Removes pages and snapshots from the in-memory session store. Optionally accepts a single key string[] key spx.hydrate"
  },
  {
    "href": "api/capture/index.html",
    "url": "/api/capture",
    "anchor": "",
    "title": "Capture",
    "text": "Api Capture The capture Promise<Page> spx.reload"
  },
  {
    "href": "api/disconnect/index.html",
    "url": "/api/disconnect",
    "anchor": "",
    "title": "Disconnect",
    "text": "Api Disconnect What is SPX?"
  },
  {
    "href": "api/connect/index.html",
    "url": "/api/connect",
    "anchor": "",
    "title": "Connect",
    "text": "Api Connect TODO spx.component"
  },
  {
    "href": "api/hydrate/index.html",
    "url": "/api/hydrate",
    "anchor": "",
    "title": "Hydrate",
    "text": "Api Hydrate Programmatic hydrate execution. The method expects a url pushState targets export function hydrate(url: string, nodes?: string[], pushState?: ‘replace’ | ‘push’): Promise spx.store"
  },
  {
    "href": "api/fetch/index.html",
    "url": "/api/fetch",
    "anchor": "",
    "title": "Fetch",
    "text": "Api Fetch The spx.fetch url The fetch method will fire the following events: spx.form"
  },
  {
    "href": "api/off/index.html",
    "url": "/api/off",
    "anchor": "",
    "title": "Off",
    "text": "Api Off TODO spx.visit"
  },
  {
    "href": "api/component/index.html",
    "url": "/api/component",
    "anchor": "",
    "title": "Component",
    "text": "Api Component spx.on"
  },
  {
    "href": "api/Observe/index.html",
    "url": "/api/observe",
    "anchor": "",
    "title": "Observe",
    "text": "Api Observe"
  },
  {
    "href": "api/on/index.html",
    "url": "/api/on",
    "anchor": "",
    "title": "On",
    "text": "Api On TODO spx.off"
  },
  {
    "href": "api/prefetch/index.html",
    "url": "/api/prefetch",
    "anchor": "",
    "title": "Prefetch",
    "text": "Api Prefetch The prefetch url <a href=\"*\"></a> The prefetch method will fire the following events: spx.fetch"
  },
  {
    "href": "api/reload/index.html",
    "url": "/api/reload",
    "anchor": "",
    "title": "Reload",
    "text": "Api Reload Triggers a reload of the current page. The page will be re-fetched over HTTP and re-cached. If fetch fails then an SSR location assignment will be invoked and redirection will be applied. spx.clear"
  },
  {
    "href": "api/session/index.html",
    "url": "/api/session",
    "anchor": "",
    "title": "Session",
    "text": "Api Session The session Returns Promise<Page> Asynchronous false"
  },
  {
    "href": "api/store/index.html",
    "url": "/api/store",
    "anchor": "",
    "title": "Store",
    "text": "Api Store The store url state Promise<Page> spx.observe"
  },
  {
    "href": "api/visit/index.html",
    "url": "/api/visit",
    "anchor": "",
    "title": "Visit",
    "text": "Api Visit The visit url Promise<Page> replace > request > cache > render > load spx.prefetch"
  },
  {
    "href": "api/render/index.html",
    "url": "/api/render",
    "anchor": "",
    "title": "SPX Methods | Render",
    "text": "Api Render The spx.render spx-append spx-prepend Use this method with mindfulness. Expensive operations was cause bottlenecks. Below is an example of the method works. You should also take a look at the SPX Infinite Scrolling spx.render Let’s assume you have click event listener setup for #next-page On this page we have 2 additional boxers in a list. Based on the method code childNodes ul #foo spx.capture"
  },
  {
    "href": "attributes/spx-bind/index.html",
    "url": "/attributes/spx-bind",
    "anchor": "",
    "title": "spx-bind",
    "text": "Attributes Spx bind The spx-bind spx-watch"
  },
  {
    "href": "attributes/spx-cache/index.html",
    "url": "/attributes/spx-cache",
    "anchor": "",
    "title": "spx-cache",
    "text": "Attributes Spx cache Controls the caching engine of each SPX navigation. When using spx-cache spx-hover Passing a false Passing a reset Passing a clear Passing a update Passing a restore spx-disable The spx-cache When annotating <button> This attribute is a string spx-disable"
  },
  {
    "href": "attributes/spx-append/index.html",
    "url": "/attributes/spx-append",
    "anchor": "",
    "title": "spx-append",
    "text": "Attributes Spx append Executes an append replacement upon visit, where the array list values are used as targets. Index [0] [1] The spx-append This attribute is a string[][] The surrounding parenthesis () spx-threshold"
  },
  {
    "href": "attributes/spx-component/index.html",
    "url": "/attributes/spx-component",
    "anchor": "",
    "title": "spx-component",
    "text": "Attributes Spx component The spx-component spx-node"
  },
  {
    "href": "attributes/spx-eval/index.html",
    "url": "/attributes/spx-eval",
    "anchor": "",
    "title": "spx-eval",
    "text": "Attributes Spx eval Used on resources contained within the <head> false <script> <script src=\"*\"></script> When a <script> spx-eval=\"false\" The spx-eval This attribute is a boolean true spx-eval spx-data"
  },
  {
    "href": "attributes/spx-data/index.html",
    "url": "/attributes/spx-data",
    "anchor": "",
    "title": "spx-data",
    "text": "Attributes Spx data The spx-data The spx-data <a> The above code sample would result be converted from kebab-case camelCase Each event will pass the data values in page state. spx-component"
  },
  {
    "href": "attributes/spx-disable/index.html",
    "url": "/attributes/spx-disable",
    "anchor": "",
    "title": "spx-disable",
    "text": "Attributes Spx disable Use on <a> spx-disable spx-cache=\"restore\" The spx-disable This attribute is a truthy true spx-disable Clicking this link will clear cache and a normal page navigation will be executed. Clicking this link will execute a normal page navigation but will inform SPX to save the current cache and restore it upon the next SPX enabled visit. See spx-history"
  },
  {
    "href": "attributes/spx-history/index.html",
    "url": "/attributes/spx-history",
    "anchor": "",
    "title": "spx-history",
    "text": "Attributes Spx history Controls the history pushstate for the navigation. Accepts false replace push false replace push The spx-history This attribute is a string spx.connect"
  },
  {
    "href": "attributes/spx-hover/index.html",
    "url": "/attributes/spx-hover",
    "anchor": "",
    "title": "spx-hover",
    "text": "Attributes Spx hover Performs a prefetch of the href <a> trigger attribute spx.connect() If you have set trigger href false <a spx-hover=\"false\"> If you set hover pre-fetching to false spx.connect() On mobile devices the the prefetch will execute on the touchstart The spx-hover This attribute is a boolean true spx-hover spx-eval"
  },
  {
    "href": "attributes/spx-hydrate/index.html",
    "url": "/attributes/spx-hydrate",
    "anchor": "",
    "title": "spx-hydrate",
    "text": "Attributes Spx hydrate Executes a controlled replacement of the defined elements. You should perform hydration when server side logic is required to adjust or apply changes to a visitors session as it will allow your application to seamlessly adapt and progressively align the UI without having to trigger a full-page reload. Hydration incurs side effects and the SPX session will be augmented, see below: The spx-hydrate Triggering via an annotated <button> This attribute is a string[] The surrounding parenthesis () Lets assume we informed SPX to trigger replacements on the #menu #main #note When performing a navigation visit the target elements #menu #main #note spx-hydrate spx-hydrate spx-intersect"
  },
  {
    "href": "attributes/spx-intersect/index.html",
    "url": "/attributes/spx-intersect",
    "anchor": "",
    "title": "spx-intersect",
    "text": "Attributes Spx intersect The spx-intersect Intersection Observer Annotating link elements with spx-intersect spx-intersect=\"true\" Intersect rootMargin threshold spx-intersect spx-intersect=\"true\" <a> <a> When using element annotation to target contained <a> spx-intersect=\"false\" Intersection triggers can perform append, prepend or replace operations when viewport matches occur. Passing a value of append prepend replace spx-intersect <a> Using intersection triggers are helpful in cases where you require scroll position to invoke fetching. The Infinite Scrolling You need to provide the value defined attribute to perform intersection triggers. For example, if you provide an append trigger via spx-intersect=\"append\" spx-append=\"\" spx-prepend"
  },
  {
    "href": "attributes/spx-node/index.html",
    "url": "/attributes/spx-node",
    "anchor": "",
    "title": "spx-node",
    "text": "Attributes Spx node The spx-node component.name component spx-component=\"*\" name spx-bind"
  },
  {
    "href": "attributes/spx-morph/index.html",
    "url": "/attributes/spx-morph",
    "anchor": "",
    "title": "spx-morph",
    "text": "Attributes Spx morph Controls DOM morphing operations and will be referenced during DOM diffing. The spx-morph morph renderer dirty spx-morph The spx-morph target <body> This attribute is a string Passing a value of attrs Passing a value of children In the below example, we will assume the that data-attr spx-morph=\"children\" Passing a value of preserve preserve spx-replace"
  },
  {
    "href": "attributes/spx-prepend/index.html",
    "url": "/attributes/spx-prepend",
    "anchor": "",
    "title": "spx-prepend",
    "text": "Attributes Spx prepend Executes a prepend replacement on visit, where the array list values are used as targets. Index [0] [1] The spx-prepend This attribute is a string[][] The surrounding parenthesis () spx-append"
  },
  {
    "href": "attributes/spx-position/index.html",
    "url": "/attributes/spx-position",
    "anchor": "",
    "title": "spx-position",
    "text": "Attributes Spx position Sets the scroll position of the next navigation. This is a space separated expression with colon separated prop and value. The spx-threshold This attribute is a number spx-progress"
  },
  {
    "href": "attributes/spx-proximity/index.html",
    "url": "/attributes/spx-proximity",
    "anchor": "",
    "title": "spx-proximity",
    "text": "Attributes Spx proximity Triggers a proximity fetch when the cursor is within range of an <a> number distance The spx-proximity <body> This attribute is a number false spx-position"
  },
  {
    "href": "attributes/spx-progress/index.html",
    "url": "/attributes/spx-progress",
    "anchor": "",
    "title": "spx-progress",
    "text": "Attributes Spx progress Controls the progress bar delay. By default, progress will use the threshold defined in configuration presets defined upon connection, else it will use the value defined on link attributes. Passing in a value of false The spx-progress This attribute can be number false spx-scroll"
  },
  {
    "href": "attributes/spx-replace/index.html",
    "url": "/attributes/spx-replace",
    "anchor": "",
    "title": "spx-replace",
    "text": "Attributes Spx replace Executes a replacement of defined targets, where each target defined in the array is replaced in the navigation visit. Targets defined in spx.connect() The spx-replace This attribute is a string[] The surrounding parenthesis () ' \" spx-hover"
  },
  {
    "href": "attributes/spx-target/index.html",
    "url": "/attributes/spx-target",
    "anchor": "",
    "title": "spx-target",
    "text": "Attributes Spx target Enables targeted replacements on specified elements. The spx-target string[] boolean true false true false targets[] spx-target <a href=\"*\"> string string[] The attributes value determines the tag annotation. Boolean values of either true false string string[] This attribute value accepts the following types: The following examples attempt to showcase spx-target spx-morph"
  },
  {
    "href": "attributes/spx-scroll/index.html",
    "url": "/attributes/spx-scroll",
    "anchor": "",
    "title": "spx-scroll",
    "text": "Attributes Spx scroll Sets scrollTop position, can be used as a simpler alias to spx-position The spx-threshold This attribute is a number spx-cache"
  },
  {
    "href": "attributes/spx-threshold/index.html",
    "url": "/attributes/spx-threshold",
    "anchor": "",
    "title": "spx-threshold",
    "text": "Attributes Spx threshold By default, this will be set to whatever preset configuration was defined in spx.connect() spx-threshold threshold The spx-threshold This attribute either a number spx-proximity"
  },
  {
    "href": "attributes/spx-track/index.html",
    "url": "/attributes/spx-track",
    "anchor": "",
    "title": "spx-track",
    "text": "Attributes Spx track The spx-track <body> svg The spx-track <body> <a> This attribute is a truthy true spx-track Lets assume you are navigating from Page 1 Page 2 #main Page 1 #main #main spx-track If navigation started on Page 2"
  },
  {
    "href": "attributes/spx-watch/index.html",
    "url": "/attributes/spx-watch",
    "anchor": "",
    "title": "spx-watch",
    "text": "Attributes Spx watch Watches an element and keeps the snapshot record aligned. spx-hydrate"
  },
  {
    "href": "components/context/index.html",
    "url": "/components/context",
    "anchor": "",
    "title": "Components - Context",
    "text": "Components Context SPX Components can control connection configuration via the static reference named connect connect The static connect object Each component will use references defined in the connect state nodes oninit connect All state nodes has boolean All components have access to the SPX lifecycle. You can use these methods to listen for operations and act in accordance. Lifecycle methods can be defined in lowercase format and will pass session reference in parameters. The main 3 lifecycle methods that you’ll use are oninit onload onexit Directives"
  },
  {
    "href": "components/directives/index.html",
    "url": "/components/directives",
    "anchor": "",
    "title": "Components - Directives",
    "text": "Components Directives SPX Components Connect templates to class components. Elements which are annotated with the spx-component kebab-case Component templates annotated with spx-component connect → state state DOM Events can be annotated to elements. The directive uses a simple spx@ . <component.<method> In some cases you may want to pass data to method callbacks in components from a DOM element. The standard (state) directive structure can be used and all annotation will be provided to the event parameter argument in the class method. Event attrs are parsed and the provided State"
  },
  {
    "href": "components/events/index.html",
    "url": "/components/events",
    "anchor": "",
    "title": "Components - Events",
    "text": "Components Events Nodes"
  },
  {
    "href": "components/nodes/index.html",
    "url": "/components/nodes",
    "anchor": "",
    "title": "Components - Nodes",
    "text": "Components Nodes spx-target"
  },
  {
    "href": "components/state/index.html",
    "url": "/components/state",
    "anchor": "",
    "title": "Components - State",
    "text": "Components State Component state is stored in the DOM and bindings are established in mounted components. State references require you define an interface model via the static connect.state In the below code snippet we have defined some state for a tab component. For developers coming from Stimulus, you’ll notice how SPX components are almost identical to how you might define values Let’s now expand on the above definitions and provide some default values to state interfaces, again this approach is similar to Stimulus, with differences being naming convention. In this example, we will instead provide a pre-defined set of disableTabs In addition to the above approaches, you may require persisted state values. Persist states will instruct SPX to preserve the state values between page navigations, skipping state resets whenever a component disconnects. Shared state instructs SPX to maintain state across all instances of a component. Changes applied to shared state is incremental and it can be controlled for multiple points in your web application. Event Listeners"
  },
  {
    "href": "components/incremental/index.html",
    "url": "/components/incremental",
    "anchor": "",
    "title": "SPX Components - Incremental",
    "text": "Components Incremental"
  },
  {
    "href": "components/structure/index.html",
    "url": "/components/structure",
    "anchor": "",
    "title": "SPX Components - Structure",
    "text": "Components Structure Positioned at the core of the module, SPX components are a straight-forward DOM enhancement for creating interactive logic within web applications. SPX Components use an scalable pattern, one which you seamlessly apply to your existing projects. The internal tactic SPX employs for components is tightly coupled together with the rendering, morphing, and caching algorithm. Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Tincidunt nunc pulvinar sapien et ligula ullamcorper malesuada proin. Ac tortor dignissim convallis aenean et tortor at risus. Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Elementum sagittis vitae et leo duis ut. Ut tortor pretium viverra suspendisse potenti. Commodo sed egestas egestas fringilla phasellus faucibus. Eu tincidunt tortor aliquam nulla facilisi cras fermentum. Nullam eget felis eget nunc lobortis mattis. Et netus et malesuada fames ac turpis egestas maecenas. Vitae turpis massa sed elementum tempus egestas. Eget mi proin sed libero enim sed faucibus turpis. Pharetra convallis posuere morbi leo urna molestie. Magna eget est lorem ipsum dolor. Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Tincidunt nunc pulvinar sapien et ligula ullamcorper malesuada proin. Ac tortor dignissim convallis aenean et tortor at risus. When components have an id Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Tincidunt nunc pulvinar sapien et ligula ullamcorper malesuada proin. Ac tortor dignissim convallis aenean et tortor at risus. Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Tincidunt nunc pulvinar sapien et ligula ullamcorper malesuada proin. Ac tortor dignissim convallis aenean et tortor at risus. Incremental components can be progressively extended upon when mounted within static fragment or targeting specific elements via spx-target Context"
  },
  {
    "href": "introduction/getting-started/index.html",
    "url": "/introduction/getting-started",
    "anchor": "",
    "title": "Getting Started",
    "text": "Introduction Getting started SPX assumes developers have an intermediate level of font-end knowledge. Before leveraging the module, it’s important to familiarize yourself with a couple of its key concepts The best way to demonstrate how you can use SPX is through a real world example. We will use a sample project and go over most of the major things you would need to deal with while using SPX. We will be integrating SPX into the below sample website which consists of 4 different pages. We will first go through SPX connection and then we will create 2 SPX Components. Lexicon"
  },
  {
    "href": "introduction/key-concepts/index.html",
    "url": "/introduction/key-concepts",
    "anchor": "",
    "title": "Key Concepts",
    "text": "Introduction Key concepts SPX assumes developers have an intermediate level of font-end knowledge. Before leveraging the module, it’s important to familiarize yourself with a couple of its key concepts which are listed on this page. When using SPX, all href XHR The actual fetching operation happens preemptively and SPX offers varying sets of user defined configuration options for performing DOM element replacements when navigating between different urls of the same hostname. SPX is designed to replicate native browser behavior but developers should be mindful in their implementation. In SPX, fragments pertain to elements annotated with the id DOM morphing, at its core, is a rendering process employed by SPX to dynamically transform the DOM during page navigation. Unlike traditional page loading approaches. Here, the fragments string[] <body> In this case, the <nav> <main> <footer> <nav> <nav> <main> <footer> By specifying the targets ['nav', 'main'] spx.connect() <nav> <main> Using targets is highly encouraged when working with SPX, as it not only improves the performance and rendering capabilities of the module but also promotes good practices when dealing with markup languages like HTML. So, leverage targets to unlock the full potential of SPX in your web application. SPX actively monitors events occurring on <a> By default, SPX ensures that all link clicks follow its prescribed behavior based on annotations present on <a> At the core of SPX lies the concept of prefetching, which plays a crucial role in determining visit intent. Prefetching allows SPX to anticipate user actions and be proactive in fetching the required content in advance. This significantly enhances the navigation experience for users. SPX offers multiple ways for developers to implement prefetching, providing flexibility and control for varying use cases. By default, SPX performs prefetches upon pointer hover events. However, this may not always be the most suitable approach for every scenario. Therefore, SPX offers three additional methods of prefetching, enabling developers to choose the most appropriate option based on their specific needs. To make the process seamless, SPX allows you to pre-define prefetch operations upon connecting to the SPX module. This means you can set up prefetching behaviors right from the start. Alternatively, if you prefer more granular control, you can customize prefetch execution on a per-link level within the DOM using attribute annotations. This allows you to fine-tune prefetching for individual links based on their importance or relevance. Moreover, you can also combine both connection presets and DOM customizations to create a comprehensive prefetching strategy tailored to your web application’s requirements. By leveraging SPX’s prefetching capabilities, you can optimize navigation efficiency, minimize loading times, and provide end-users with a more refined experience. SPX incorporates an efficient in-memory cache to store fetched pages. After each visit, a snapshot representing the raw DOM as a string is stored in the browser’s local memory. While this might raise concerns about performance, it’s worth noting that SPX snapshots are relatively inexpensive in terms of memory usage. Each SPX snapshot (DOM String) remains accessible throughout an SPX session, preserving the state of the visited pages. The cache is available until a full page refresh occurs or the hostname changes, ensuring seamless navigation within the session. The cache algorithm employed by SPX is pre-emptive, making visits a low-cost operation. SPX executes visits asynchronously and sequentially, without blocking other tasks. Requests can be easily aborted, queued, and prioritized, which is particularly useful when multiple requests are awaiting processing, and a user clicks on a link that’s at the end of the queue. SPX’s intelligent handling ensures smooth and optimized navigation in such cases. Additionally, SPX makes use of the HistoryAPI state Getting Started"
  },
  {
    "href": "introduction/lexicon/index.html",
    "url": "/introduction/lexicon",
    "anchor": "",
    "title": "Lexicon",
    "text": "Introduction Lexicon The SPX Lexicon uses relative naming conventions to describe capabilities, features and usage. This page is a glossary of common SPX terminologies you’ll come across in the documentation and when using the library in your project. Naming conventions are difficult and SPX appropriates familiar terminologies that developers or alternative frameworks/libraries use but there differences. If you’re coming from stimulus, you’ll find that SPX refers to “controllers” as “components” or if you’re coming from Alpine, you’ll find that “directives” and not exclusive to all attributes, but only those which are component specific. A A A The A <main> A A An A spx-node A spx-bind spx-bind An Sessions"
  },
  {
    "href": "introduction/session/index.html",
    "url": "/introduction/session",
    "anchor": "",
    "title": "Session",
    "text": "Introduction Session An SPX session begins when the module has been connected (see connection The right sidebar represents the current SPX session taking place as you navigate the documentation. It provides a (partial) visual representation of the caching engine in real-time, and the varying models of a session. You can inspect the SPX session using the spx.session() The pages <a> Lifecycle Methods"
  },
  {
    "href": "introduction/what-is-spx/index.html",
    "url": "/introduction/what-is-spx",
    "anchor": "",
    "title": "Introduction",
    "text": "Introduction What is spx SPX is a lightweight (15kb gzip) JavaScript library for static, SaaS and server-side powered web applications that pre-fetches HTML over the wire and uses the response to perform targeted fragment replacements. The module executes navigation in an idle state, maintains an in-memory cache of fetched pages that prevents subsequent requests from occurring and carries out morphed renders between visits and supports component integration. Gzipped distribution size for related modules. SPX ~ 15kb HTMX + Idiomorph ~ 20kb Alpine + Packages ~ 30kb Stimulus + Turbo ~ 30kb Rendering based performance metrics are estimated. SPX ~ 150ms HTMX ~ 250ms Alpine ~ 450ms Stimulus + Turbo ~ 550ms The name “SPX” is an acronym for The effectiveness of SPX’s approach has been tried and tested. Modules like Turbo HTMX Livewire Barba SPX offers a unique and tailored proposition that sets it apart from similar alternatives. It introduces innovative techniques to the OTW (over the wire) paradigm and combines them with strategies standardized in similar projects. At the core of the SPX model is the user’s intent-to-visit. Over the wire page requests (fetches) are treated as background operations that typically execute and conclude before a navigation even begins. The main objective with SPX is to provide a solution that is inexpensive but powerful, though there is a tax incurred, the project attempts to eliminate technical debt. SPX was originally developed to improve Time to First Byte (TTFB) performance in Shopify (Liquid) powered webshop’s and is successfully employed in production by reputable brands like Brixtol Textiles This website is using SPX. It aims to demonstrate how SPX operates and showcase some of the capabilities it provides and it’s best viewed on desktop for an optimal experience. As you explore the documentation, pay attention to the right side, where you can witness the caching engine in real-time. When you mouse over certain links or when the cursor is in close proximity to a link element, you’ll notice that the pages The pages snapshots history Key Concepts"
  },
  {
    "href": "introduction/lifecycle/index.html",
    "url": "/introduction/lifecycle",
    "anchor": "",
    "title": "Lifecycle",
    "text": "Introduction Lifecycle SPX takes over the rendering cycle in your web application and exposes an visit lifecycle that you can hook into to perform operations at different points. If you’ve worked with virtual DOM frameworks, you’ll likely be familiar with lifecycle methods. SPX takes inspiration from the brilliant SPA framework known as mithril.js You can access the lifecycle using SPX events listeners. There is no limit to the amount of events you and SPX will dispatch in sequential order, starting from the first defined listener to the last. Components can hook into the lifecycle directly within class using the below methods. Component hooks will pass the same parameters as the listeners, but will not bind anything to the this Installation"
  },
  {
    "href": "examples/components/index.html",
    "url": "/examples/components",
    "anchor": "",
    "title": "SPX Examples | Components",
    "text": "Examples Components Clicked XXX: 0 Clicked YYY: 0 Clicked: 0 Click this div and the value of spx-bar:change This text content will change when you click the div Resize Window to see value: 0 Mouseover (hover) this pink box: 0 7"
  },
  {
    "href": "examples/infinite-scrolling/index.html",
    "url": "/examples/infinite-scrolling",
    "anchor": "",
    "title": "SPX Examples | Infinite Scrolling",
    "text": "Examples Infinite scrolling This example show how you can leverage SPX to perform infinite scrolling pagination. The example leverages the spx.render() might spx.render Press the Load More"
  },
  {
    "href": "examples/hover-prefetch/index.html",
    "url": "/examples/hover-prefetch",
    "anchor": "",
    "title": "SPX Examples | Hover Prefetch",
    "text": "Examples Hover prefetch"
  },
  {
    "href": "examples/intersect-prefetch/index.html",
    "url": "/examples/intersect-prefetch",
    "anchor": "",
    "title": "SPX Examples | Intersect Prefetch",
    "text": "Examples Intersect prefetch"
  },
  {
    "href": "examples/proximity-prefetch/index.html",
    "url": "/examples/proximity-prefetch",
    "anchor": "",
    "title": "SPX Examples | Proximity Prefetch",
    "text": "Examples Proximity prefetch"
  },
  {
    "href": "examples/script-evaluation/index.html",
    "url": "/examples/script-evaluation",
    "anchor": "",
    "title": "SPX Examples | Script Evaluation",
    "text": "Examples Script evaluation Page A Page B Page C"
  },
  {
    "href": "examples/tabs/index.html",
    "url": "/examples/tabs",
    "anchor": "",
    "title": "SPX Examples | Tabs",
    "text": "Examples Tabs"
  },
  {
    "href": "misc/acknowledgements/index.html",
    "url": "/misc/acknowledgements",
    "anchor": "",
    "title": "SPX | Acknowledgements",
    "text": "Misc Acknowledgements SPX is made possible with the help of contributors and and other awesome open source packages. Mansedan who was early adopter of SPX and helped work through various edge cases scenarios. The Morphdom The Turbo/Turbolinks approach is a partial concept that SPX is very loosely based upon. Thanks to Basecamp Hey Special Thanks / Спасибі to Alexey"
  },
  {
    "href": "usage/basic-example/index.html",
    "url": "/usage/basic-example",
    "anchor": "",
    "title": "Basic Example",
    "text": "Usage Basic example Below is a real world example you can use to better understand how SPX works. The first thing we want to do is make a connection with SPX. In your JavaScript bundle, initialize (connect) SPX preferably before any other scripts. This example web application has 3 pages, the <nav> <main> data-spx The about page in our web application would look practically identical to the home page. We instructed SPX to prefetch this page upon hover by annotating the <a> spx-hover <a> threshold The The contact page will replace an additional fragment with the id value of foo <nav> <main> <div id=\"foo\">"
  },
  {
    "href": "misc/benchmarks/index.html",
    "url": "/misc/benchmarks",
    "anchor": "",
    "title": "SPX | Benchmarks",
    "text": "Misc Benchmarks TODO"
  },
  {
    "href": "usage/connection/index.html",
    "url": "/usage/connection",
    "anchor": "",
    "title": "Connection",
    "text": "Usage Connection SPX requires invoking and can be initialized using the spx.connect() document.documentElement.outerHTML SPX Connection using default options SPX Connection using default options with callback: SPX Connection with fragment[] Options"
  },
  {
    "href": "usage/installation/index.html",
    "url": "/usage/installation",
    "anchor": "",
    "title": "Installation",
    "text": "Usage Installation SPX is available for consumption via the NPM SPX is distributed as an ESM ES6 If you’re new to JavaScript or just want a very simple setup, you can get SPX from CDN and drop it into your website. Be sure to include SPX before any other JavaScript files and to also include the type=\"module\" <body> Connection"
  },
  {
    "href": "usage/options/index.html",
    "url": "/usage/options",
    "anchor": "",
    "title": "Options",
    "text": "Usage Options The spx.connect connection targets A list of element selectors to swap on a per-page basis. By default, SPX will replace the entire <body> Whether or not the SPX connection instance should be made available to globalThis (e.g: window.spx window Whether or not you want to manually invoke observers. This defaults to false false spx.observe() By default, attribute identifiers use an spx- null null validators spx- data-spx Request polling limit is used when a request is already in transit. By default this is set to 30000 30s Request polling limit is used when a request is already in transit. By default this is set to 30000 30s Level Mode Description 1 DEBUG Used in development only. Applies detailed logging of varying operations. 2 VERBOSE Less aggressive than DEBUG, informative logging overall. 3 INFO Info related logging, less aggressive than VERBOSE. Default level. 4 WARN Only prints warnings or errors, recommended for production. 5 ERROR Errors only. This is effectively silent mode, only throws will apply. Enable or Disable caching. Each page visit request is cached and used in subsequent visits to the same location. Setting this to false spx-cache Cache size limit. SPX limits cache size to 100mb Components registry. Expects an object Hover prefetching. You can disable hover pre-fetching by setting this to false spx-hover truetrigger How hover prefetches should be triggered. By default this option is set to trigger only when <a> spx-hover <a> href href spx-hover=\"false\"threshold Controls the fetch delay threshold, defaults to 250 Proximity pre-fetching allow for requests to be dispatched when the cursor is within a proximity range of a href link element. Coupling proximity with mouseover prefetches enable predicative fetching to occur, so a request will trigger before any interaction with a link element happens. To use default behavior, set this to true <a> spx-proximity <a> spx-proximity=\"false\"distance The proximity distance range defaults to 75 spx-proximity=\"50\" 50pxthrottle The proximity throttle defaults to 250threshold Controls the fetch delay threshold. Requests will fire only when the mouse has exceeded the range and the threshold time limit defined here has been exceeded. Intersection pre-fetching. Intersect pre-fetching leverages the Intersection Observer false To use default behavior, set this to true spx-intersect spx-intersect=\"true\" <a> <a> spx-intersect=\"false\"rootMargin The proximity distance range defaults to 75 spx-proximity=\"50\" 50pxthreshold Throttle limit passed to the intersection observer instance. Control evaluation of specific tags which either refer to resources or control DOM behavior. These are typically tags located in the <head> spx-evalscript Whether or not <script> <script src=\"*\"> boolean <script> <script src=\"\">style Whether or not <style> <link rel=\"stylesheet\">link Whether or not <link> <link rel=\"preload\"> <link rel=\"stylesheet\">meta Whether or not <meta> <meta> Resource Evaluation"
  },
  {
    "href": "usage/using-typescript/index.html",
    "url": "/usage/using-typescript",
    "anchor": "",
    "title": "SPX - Using TypeScript",
    "text": "Usage Using typescript SPX is written in TypeScript and provides thorough type coverage. Every definition is accompanied by detailed JSDoc annotations, providing in-depth descriptions, documentation reference links and code examples. Leveraging of SPX into TypeScript projects is straightforward. All accessible types are exposed within the SPX namespace, granting easy access to all available definitions. Components are will always extend the spx.Component typeof connect this.state Type constructors can also accept inferred types and the provision will behave in accordance with the definition. This is helpful when using Object Array String SPX cannot auto-type node occurrences within components, but does support index signatures using string literal formations. Type validations will apply but not type completions. This is a limitation of TypeScript, so for developers who desire completions for nodes, you’ll need to manually type them on classes. Event methods for components are inferred at the parameter level. SPX introduces a variety of event type utilities to address diverse cases and event types. In instances where events include attrs VSCode Extension"
  },
  {
    "href": "usage/vscode-extension/index.html",
    "url": "/usage/vscode-extension",
    "anchor": "",
    "title": "VSCode Extension",
    "text": "Usage Vscode extension Developers using the VSCode SPX Extension The SPX extension contributes the following workspace settings: Structure"
  },
  {
    "href": "examples/hydration/index.html",
    "url": "/examples/hydration",
    "anchor": "",
    "title": "SPX Examples | Hydration",
    "text": "Examples Hydration"
  },
  {
    "href": "usage/resource-evaluation/index.html",
    "url": "/usage/resource-evaluation",
    "anchor": "",
    "title": "Resource Evaluation",
    "text": "Usage Resource evaluation External resources linked within <script> <link> For optimal performance it is recommended that you limit resource evaluation to the absolute minimum and if possible trigger your projects execution at runtime. Resources control is made available upon connection via the eval eval boolean object object Attribute Selectors Connection settings are treated as defaults, and developers can override eval spx-eval spx-eval boolean true false Script occurrences in the DOM are evaluated and initialized asynchronously. By default, re-evaluation applies to all inline scripts whereas linked scripts (i.e <script src=\"\"> In cases where the default behavior is problematic, you can configure SPX to perform re-evaluation on a per-resource basis control using the spx-eval attribute or eval configuration option. Scripts that exist in the <body>`` or within defined fragments should be avoided. There is little necessity for In order to get the most out of this module below are a few recommendations developers should consider when leveraging it in their projects. SPX was developed for certain use cases but using it on its own can be a tad vanilla, as such developers are encouraged to couple it with other modules. JavaScript evaluation between navigations is supported when <script> <head> <body> import('.') Stylesheet and inline CSS evaluation is supported for <style> <link rel=\"stylesheet> <head> <body> <link> spx-eval=\"true\" The pre-fetching capabilities this SPX variation provides can drastically improve the speed of rendering. When used correctly pages will load instantaneously between navigations. By default, the pre-fetching features are opt-in and require attribute annotation but you can customize how, where and when SPX should execute a pre-fetch. SPX works great with stimulus.js The best possible approach when you need to invoke JavaScript like Google Analytics and scripts which require per-page execution is to use the spx.on('load') By default, all fetched pages are stored in memory so for every request the HTML dom string response will be in cache. The smaller your HTML pages the more performant the rendering engine will operate. In addition to minification it is generally good practice to consider using semantic HTML5 as much as possible this will help negate the amount of markup pages require. TODO TODO TODO TODO Using TypeScript"
  },
  {
    "href": "examples/infinite-scrolling/page-1/index.html",
    "url": "/examples/infinite-scrolling/page-1",
    "anchor": "",
    "title": "SPX Examples | Infinite Scrolling (Page 1)",
    "text": "Examples Infinite scrolling Page 1 Load More"
  },
  {
    "href": "examples/infinite-scrolling/page-2/index.html",
    "url": "/examples/infinite-scrolling/page-2",
    "anchor": "",
    "title": "SPX Examples | Infinite Scrolling (Page 2)",
    "text": "Examples Infinite scrolling Page 2 Load More"
  },
  {
    "href": "examples/infinite-scrolling/page-3/index.html",
    "url": "/examples/infinite-scrolling/page-3",
    "anchor": "",
    "title": "SPX Examples | Infinite Scrolling (Page 3)",
    "text": "Examples Infinite scrolling Page 3"
  },
  {
    "href": "examples/script-evaluation/page-b/index.html",
    "url": "/examples/script-evaluation/page-b",
    "anchor": "",
    "title": "SPX Examples | Script Evaluation - Page B",
    "text": "Examples Script evaluation Page b Index Page A Page B Page C I am Page B"
  },
  {
    "href": "examples/script-evaluation/page-c/index.html",
    "url": "/examples/script-evaluation/page-c",
    "anchor": "",
    "title": "SPX Examples | Script Evaluation - Page C",
    "text": "Examples Script evaluation Page c Index Page A Page B Page C I am Page C"
  },
  {
    "href": "examples/script-evaluation/page-a/index.html",
    "url": "/examples/script-evaluation/page-a",
    "anchor": "",
    "title": "SPX Examples | Script Evaluation - Page A",
    "text": "Examples Script evaluation Page a Index Page A Page B I am Page A"
  },
  {
    "href": "views/docs/attributes/index.html",
    "url": "/views/docs/attributes",
    "anchor": "",
    "title": "",
    "text": "Elements can be annotated with spx-* -spx- connect schema"
  },
  {
    "href": "views/docs/components/algorithm/index.html",
    "url": "/views/docs/components/algorithm",
    "anchor": "",
    "title": "",
    "text": "The SPX Component algorithm (or pattern) works in a progressive manner. This page intends to describe the internal logic applied to component handling and how things work under the hood. SPX uses syntactical structures that cannot be obtained using querySelector Runtime context happens upon SPX connection. This is a heavy operation and likely the most expensive in terms of performance bottlenecks (depending on the size of the DOM), however in most cases will conclude in less than 50ms. Runtime context works in a similar way as subsequent context, the difference being is that subsequent context is composed during morph operations, whereas runtime context is component using DOM traversal."
  },
  {
    "href": "views/docs/misc/methods/index.html",
    "url": "/views/docs/misc/methods",
    "anchor": "",
    "title": "",
    "text": "In addition to Lifecycle events, you also have a list of methods available. Methods will allow you some basic programmatic control of the SPX session occurring and provides access to the cache store, snapshot store and various other operational utilities."
  },
  {
    "href": "views/docs/lifecycle/events/index.html",
    "url": "/views/docs/lifecycle/events",
    "anchor": "",
    "title": "",
    "text": "SPX dispatches lifecycle events to the document. You can access contextual information in the parameters and carry out additional operations at different points of the SPX render cycle. Events can be cancelled with preventDefault() false The SPX lifecycle events will be triggered in the following order of execution:"
  }
]